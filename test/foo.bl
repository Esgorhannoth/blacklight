;; Reading a File

$new         ;; creates new stack(2), pushing old stack(1) onto the meta-stack
o-new        ;; creates a new object(1) and puts it on top of the @stack
errs:        ;; creates slot ‘errs’ on object(1) and stores reference to stack(1)
             ;; the @stack now only contains object(1)
'examples/hello_world.bl'
             ;; ^- put a character-vector on the stack
newq         ;; creates a new queue(1) and puts it on top of the @stack
read         ;; opens the 'text.txt' file for reading
q-to-cv      ;; converts the queue into a vector giving us “Hello world!"
greeting:    ;; make the object into [errs:s1 greeting:’Hello world!’]

;; Inverting a Stack

<> @
. drop rot swap push swap .
. @ depth swap drop 0 eq rot rot 2 drop .
until

;; Smalltalk-style Conditionals

o-new      ;; o1 will house our truthy and falsey objects

o-new      ;; o2 (truthy object)
. call .   ;; evaluate the wv
is-true:   ;; store function in slot
. drop .   ;; do nothing except get rid of the wv
is-false:  ;; store function in slot
true:      ;; store o2 in slot in o1

o-new      ;; o3 (falsy object)
. drop .   ;; do nothing except get rid of the wv
is-true:   ;; store function in slot
. call .   ;; evaluate the wv
is-false:  ;; store function in slot
false:     ;; store o3 in slot in o1

:false     ;; summon reference to falsey o3
. 'I am so false.' print .  ;; a WV to demonstrate the condition
:is-false  ;; call is-false on o3, will display "I am so false."

;; A Slot Chaining Implementation

o-new        ;; this will be our root object
.            ;; start of send, expects: @< … wv o1 >
  swap       ;; the o will be on top, there should be a WV below it
  v-to-s     ;; convert the wv to a series of word items on a user-stack
             ;; end of init
  :verify    ;; begin verify/call recursion
             ;; start of deinit
  drop       ;; remove the user-stack we created above
.            ;; end of send
send:
.            ;; expects: @< … o s > which we set up in send:
  pop        ;; get the top w from the s and put onto @stack @< … o1 o2 s w >

  ;; make copy and put copy on stack
  dup        ;; replicate the w @< … o1 o2 s w w>
  rot        ;; then bring the s to the top @< … o1 o2 w w s >
  swap       ;; finally bring a w to the top @< … o1 o2 w s w >
  push       ;; put the w back on the s @< … o1 o2 w s >
  swap       ;; bring the w to the top @< … o1 o2 s w >

  ;; validate word
  W          ;; identifier meaning “word” @< … o1 o2 s w W >
  is         ;; checks to see if the w is actually a word @< … o1 o2 s w b >
  swap drop  ;; @< … o1 o2 s b >

  ;; determine whether to call
  ..         ;; create a new sub-wv
    self     ;; it will call self @< … o >
    :call    ;; get slot from self @< … >
  ..         ;; end sub-wv
  swap       ;; @< … o1 o2 s wv b >
  if         ;; @< … o1 o2 s >
.
verify:
.            ;; expects @< … o s >
  pop        ;; get the first w from the user-stack and put onto the @stack
  rot swap   ;; makes our @stack like @< … s o w >
  get        ;; get the value in slot w @< … s o i >
  rot        ;; bring the user-stack back the top @< … o i s >
  self       ;; @< … o i s o >
  :verify    ;; @< … o i s >
.
call:

;; Below is a WIP for send that calls “send” on any returned object
;; instead of re-using the starting send, ignore for now

.
  :send     ;; call the send available on *that* object
.         ;; end block
send:     ;; save send slot
.         ;; this begins our “method chain"
  :false     ;; first we’ll access the slot with this name
  :is-false  ;; then, we’ll access the slot from that
.           ;; end method chain
swap      ;; put the o on top so we can use the get-slot below
:send     ;; this should send the above series of messages through the objects

;; Converting c's into a cv Using an until Loop

nil
\! \o \l \l \e \H
v-new
. swap app .
. nil is .
until
drop
;; @< ‘Hello!' >

;; Converting c’s into a cv Using an Object and Recursion

o-new                        ;; create a new object to store our function
.                            ;; start a wv block for our entry function
  v-new                        ;; create a new vector for our conversion
  swap                         ;; put the object back on top
  :loop-c-to-v                 ;; this will call the loop function
.                            ;; end block
c-to-v:                      ;; store our entry function
.                            ;; start a wv block for our loop function
  swap                         ;; get the c beneath our o
  app                         ;; pop the c and put it into the v
  self                         ;; reference self (self references auto-destruct)
  ~loop-c-to-v                 ;; specify name of own slot
  fetch                        ;; fetch own function (this currently running one)
  rot                          ;; bring 3rd item to top
  C is if                         ;; check to see if the top item is a c and loop if so
.                            ;; end block
loop-c-to-v:                 ;; store our recursive function
$new                         ;; new @stack
\! \o \l \l \e \H            ;; dump in our c's
^ pop dup rot push drop  ;; retrieve our object
:c-to-v                      ;; call our looping function
swap drop                    ;; get rid of the o
;; @< ‘Hello!’ >                  ;; the contents of @stack is a cv

;; Faking o-fetch

o-new
. dup mul .    ;; just an example wv: the basic implementation of sqr
v-to-q       ;; convert the wv into a q
swap drop    ;; get rid of the wv
fetch_sqr:   ;; set slot “fetch_sqr” on o to q
drop         ;; we’re done with the q
. :fetch_sqr q-to-v call 2 drop .  ;; function to get and call sqr_q
sqr:         ;; store function
2 swap :sqr  ;;=> 4
drop         ;; drop the 4
:fetch_sqr   ;;=> . dup mul .

;; Replicating q-to-v with an proq Loop

;; given @< {} >
() swap . deq app . proq

